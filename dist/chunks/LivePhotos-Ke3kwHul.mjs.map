{"version":3,"file":"LivePhotos-Ke3kwHul.mjs","sources":["../../apps/files/src/actions/moveOrCopyActionUtils.ts","../../apps/files/src/actions/moveOrCopyAction.ts","../../apps/files/src/services/LivePhotos.ts"],"sourcesContent":["/**\n * @copyright Copyright (c) 2023 John Molakvoæ <skjnldsv@protonmail.com>\n *\n * @author John Molakvoæ <skjnldsv@protonmail.com>\n *\n * @license AGPL-3.0-or-later\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as\n * published by the Free Software Foundation, either version 3 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see <http://www.gnu.org/licenses/>.\n *\n */\n\nimport '@nextcloud/dialogs/style.css'\n\nimport type { Folder, Node } from '@nextcloud/files'\nimport { Permission } from '@nextcloud/files'\nimport PQueue from 'p-queue'\n\n// This is the processing queue. We only want to allow 3 concurrent requests\nlet queue: PQueue\n\n/**\n * Get the processing queue\n */\nexport const getQueue = () => {\n\tif (!queue) {\n\t\tqueue = new PQueue({ concurrency: 3 })\n\t}\n\treturn queue\n}\n\ntype ShareAttribute = {\n\tenabled: boolean\n\tkey: string\n\tscope: string\n}\n\nexport enum MoveCopyAction {\n\tMOVE = 'Move',\n\tCOPY = 'Copy',\n\tMOVE_OR_COPY = 'move-or-copy',\n}\n\nexport type MoveCopyResult = {\n\tdestination: Folder\n\taction: MoveCopyAction.COPY | MoveCopyAction.MOVE\n}\n\nexport const canMove = (nodes: Node[]) => {\n\tconst minPermission = nodes.reduce((min, node) => Math.min(min, node.permissions), Permission.ALL)\n\treturn (minPermission & Permission.UPDATE) !== 0\n}\n\nexport const canDownload = (nodes: Node[]) => {\n\treturn nodes.every(node => {\n\t\tconst shareAttributes = JSON.parse(node.attributes?.['share-attributes'] ?? '[]') as Array<ShareAttribute>\n\t\treturn !shareAttributes.some(attribute => attribute.scope === 'permissions' && attribute.enabled === false && attribute.key === 'download')\n\n\t})\n}\n\nexport const canCopy = (nodes: Node[]) => {\n\t// For now the only restriction is that a shared file\n\t// cannot be copied if the download is disabled\n\treturn canDownload(nodes)\n}\n","/**\n * @copyright Copyright (c) 2023 John Molakvoæ <skjnldsv@protonmail.com>\n *\n * @author John Molakvoæ <skjnldsv@protonmail.com>\n *\n * @license AGPL-3.0-or-later\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as\n * published by the Free Software Foundation, either version 3 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see <http://www.gnu.org/licenses/>.\n *\n */\nimport '@nextcloud/dialogs/style.css'\nimport type { Folder, Node, View } from '@nextcloud/files'\nimport type { IFilePickerButton } from '@nextcloud/dialogs'\nimport type { FileStat, ResponseDataDetailed } from 'webdav'\nimport type { MoveCopyResult } from './moveOrCopyActionUtils'\n\n// eslint-disable-next-line n/no-extraneous-import\nimport { AxiosError } from 'axios'\nimport { basename, join } from 'path'\nimport { emit } from '@nextcloud/event-bus'\nimport { FilePickerClosed, getFilePickerBuilder, showError } from '@nextcloud/dialogs'\nimport { Permission, FileAction, FileType, NodeStatus, davGetClient, davRootPath, davResultToNode, davGetDefaultPropfind } from '@nextcloud/files'\nimport { translate as t } from '@nextcloud/l10n'\nimport Vue from 'vue'\n\nimport CopyIconSvg from '@mdi/svg/svg/folder-multiple.svg?raw'\nimport FolderMoveSvg from '@mdi/svg/svg/folder-move.svg?raw'\n\nimport { MoveCopyAction, canCopy, canMove, getQueue } from './moveOrCopyActionUtils'\nimport logger from '../logger'\nimport { getUniqueName } from '../utils/fileUtils'\n\n/**\n * Return the action that is possible for the given nodes\n * @param {Node[]} nodes The nodes to check against\n * @return {MoveCopyAction} The action that is possible for the given nodes\n */\nconst getActionForNodes = (nodes: Node[]): MoveCopyAction => {\n\tif (canMove(nodes)) {\n\t\tif (canCopy(nodes)) {\n\t\t\treturn MoveCopyAction.MOVE_OR_COPY\n\t\t}\n\t\treturn MoveCopyAction.MOVE\n\t}\n\n\t// Assuming we can copy as the enabled checks for copy permissions\n\treturn MoveCopyAction.COPY\n}\n\n/**\n * Handle the copy/move of a node to a destination\n * This can be imported and used by other scripts/components on server\n * @param {Node} node The node to copy/move\n * @param {Folder} destination The destination to copy/move the node to\n * @param {MoveCopyAction} method The method to use for the copy/move\n * @param {boolean} overwrite Whether to overwrite the destination if it exists\n * @return {Promise<void>} A promise that resolves when the copy/move is done\n */\nexport const handleCopyMoveNodeTo = async (node: Node, destination: Folder, method: MoveCopyAction.COPY | MoveCopyAction.MOVE, overwrite = false) => {\n\tif (!destination) {\n\t\treturn\n\t}\n\n\tif (destination.type !== FileType.Folder) {\n\t\tthrow new Error(t('files', 'Destination is not a folder'))\n\t}\n\n\t// Do not allow to MOVE a node to the same folder it is already located\n\tif (method === MoveCopyAction.MOVE && node.dirname === destination.path) {\n\t\tthrow new Error(t('files', 'This file/folder is already in that directory'))\n\t}\n\n\t/**\n\t * Example:\n\t * - node: /foo/bar/file.txt -> path = /foo/bar/file.txt, destination: /foo\n\t *   Allow move of /foo does not start with /foo/bar/file.txt so allow\n\t * - node: /foo , destination: /foo/bar\n\t *   Do not allow as it would copy foo within itself\n\t * - node: /foo/bar.txt, destination: /foo\n\t *   Allow copy a file to the same directory\n\t * - node: \"/foo/bar\", destination: \"/foo/bar 1\"\n\t *   Allow to move or copy but we need to check with trailing / otherwise it would report false positive\n\t */\n\tif (`${destination.path}/`.startsWith(`${node.path}/`)) {\n\t\tthrow new Error(t('files', 'You cannot move a file/folder onto itself or into a subfolder of itself'))\n\t}\n\n\t// Set loading state\n\tVue.set(node, 'status', NodeStatus.LOADING)\n\n\tconst queue = getQueue()\n\treturn await queue.add(async () => {\n\t\tconst copySuffix = (index: number) => {\n\t\t\tif (index === 1) {\n\t\t\t\treturn t('files', '(copy)') // TRANSLATORS: Mark a file as a copy of another file\n\t\t\t}\n\t\t\treturn t('files', '(copy %n)', undefined, index) // TRANSLATORS: Meaning it is the n'th copy of a file\n\t\t}\n\n\t\ttry {\n\t\t\tconst client = davGetClient()\n\t\t\tconst currentPath = join(davRootPath, node.path)\n\t\t\tconst destinationPath = join(davRootPath, destination.path)\n\n\t\t\tif (method === MoveCopyAction.COPY) {\n\t\t\t\tlet target = node.basename\n\t\t\t\t// If we do not allow overwriting then find an unique name\n\t\t\t\tif (!overwrite) {\n\t\t\t\t\tconst otherNodes = await client.getDirectoryContents(destinationPath) as FileStat[]\n\t\t\t\t\ttarget = getUniqueName(node.basename, otherNodes.map((n) => n.basename), copySuffix)\n\t\t\t\t}\n\t\t\t\tawait client.copyFile(currentPath, join(destinationPath, target))\n\t\t\t\t// If the node is copied into current directory the view needs to be updated\n\t\t\t\tif (node.dirname === destination.path) {\n\t\t\t\t\tconst { data } = await client.stat(\n\t\t\t\t\t\tjoin(destinationPath, target),\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tdetails: true,\n\t\t\t\t\t\t\tdata: davGetDefaultPropfind(),\n\t\t\t\t\t\t},\n\t\t\t\t\t) as ResponseDataDetailed<FileStat>\n\t\t\t\t\temit('files:node:created', davResultToNode(data))\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tawait client.moveFile(currentPath, join(destinationPath, node.basename))\n\t\t\t\t// Delete the node as it will be fetched again\n\t\t\t\t// when navigating to the destination folder\n\t\t\t\temit('files:node:deleted', node)\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tif (error instanceof AxiosError) {\n\t\t\t\tif (error?.response?.status === 412) {\n\t\t\t\t\tthrow new Error(t('files', 'A file or folder with that name already exists in this folder'))\n\t\t\t\t} else if (error?.response?.status === 423) {\n\t\t\t\t\tthrow new Error(t('files', 'The files is locked'))\n\t\t\t\t} else if (error?.response?.status === 404) {\n\t\t\t\t\tthrow new Error(t('files', 'The file does not exist anymore'))\n\t\t\t\t} else if (error.message) {\n\t\t\t\t\tthrow new Error(error.message)\n\t\t\t\t}\n\t\t\t}\n\t\t\tlogger.debug(error as Error)\n\t\t\tthrow new Error()\n\t\t} finally {\n\t\t\tVue.set(node, 'status', undefined)\n\t\t}\n\t})\n}\n\n/**\n * Open a file picker for the given action\n * @param {MoveCopyAction} action The action to open the file picker for\n * @param {string} dir The directory to start the file picker in\n * @param {Node[]} nodes The nodes to move/copy\n * @return {Promise<MoveCopyResult>} The picked destination\n */\nconst openFilePickerForAction = async (action: MoveCopyAction, dir = '/', nodes: Node[]): Promise<MoveCopyResult> => {\n\tconst fileIDs = nodes.map(node => node.fileid).filter(Boolean)\n\tconst filePicker = getFilePickerBuilder(t('files', 'Choose destination'))\n\t\t.allowDirectories(true)\n\t\t.setFilter((n: Node) => {\n\t\t\t// We only want to show folders that we can create nodes in\n\t\t\treturn (n.permissions & Permission.CREATE) !== 0\n\t\t\t\t// We don't want to show the current nodes in the file picker\n\t\t\t\t&& !fileIDs.includes(n.fileid)\n\t\t})\n\t\t.setMimeTypeFilter([])\n\t\t.setMultiSelect(false)\n\t\t.startAt(dir)\n\n\treturn new Promise((resolve, reject) => {\n\t\tfilePicker.setButtonFactory((_selection, path: string) => {\n\t\t\tconst buttons: IFilePickerButton[] = []\n\t\t\tconst target = basename(path)\n\n\t\t\tconst dirnames = nodes.map(node => node.dirname)\n\t\t\tconst paths = nodes.map(node => node.path)\n\n\t\t\tif (action === MoveCopyAction.COPY || action === MoveCopyAction.MOVE_OR_COPY) {\n\t\t\t\tbuttons.push({\n\t\t\t\t\tlabel: target ? t('files', 'Copy to {target}', { target }) : t('files', 'Copy'),\n\t\t\t\t\ttype: 'primary',\n\t\t\t\t\ticon: CopyIconSvg,\n\t\t\t\t\tasync callback(destination: Node[]) {\n\t\t\t\t\t\tresolve({\n\t\t\t\t\t\t\tdestination: destination[0] as Folder,\n\t\t\t\t\t\t\taction: MoveCopyAction.COPY,\n\t\t\t\t\t\t} as MoveCopyResult)\n\t\t\t\t\t},\n\t\t\t\t})\n\t\t\t}\n\n\t\t\t// Invalid MOVE targets (but valid copy targets)\n\t\t\tif (dirnames.includes(path)) {\n\t\t\t\t// This file/folder is already in that directory\n\t\t\t\treturn buttons\n\t\t\t}\n\n\t\t\tif (paths.includes(path)) {\n\t\t\t\t// You cannot move a file/folder onto itself\n\t\t\t\treturn buttons\n\t\t\t}\n\n\t\t\tif (action === MoveCopyAction.MOVE || action === MoveCopyAction.MOVE_OR_COPY) {\n\t\t\t\tbuttons.push({\n\t\t\t\t\tlabel: target ? t('files', 'Move to {target}', { target }) : t('files', 'Move'),\n\t\t\t\t\ttype: action === MoveCopyAction.MOVE ? 'primary' : 'secondary',\n\t\t\t\t\ticon: FolderMoveSvg,\n\t\t\t\t\tasync callback(destination: Node[]) {\n\t\t\t\t\t\tresolve({\n\t\t\t\t\t\t\tdestination: destination[0] as Folder,\n\t\t\t\t\t\t\taction: MoveCopyAction.MOVE,\n\t\t\t\t\t\t} as MoveCopyResult)\n\t\t\t\t\t},\n\t\t\t\t})\n\t\t\t}\n\n\t\t\treturn buttons\n\t\t})\n\n\t\tconst picker = filePicker.build()\n\t\tpicker.pick().catch((error) => {\n\t\t\tlogger.debug(error as Error)\n\t\t\tif (error instanceof FilePickerClosed) {\n\t\t\t\treject(new Error(t('files', 'Cancelled move or copy operation')))\n\t\t\t} else {\n\t\t\t\treject(new Error(t('files', 'Move or copy operation failed')))\n\t\t\t}\n\t\t})\n\t})\n}\n\nexport const action = new FileAction({\n\tid: 'move-copy',\n\tdisplayName(nodes: Node[]) {\n\t\tswitch (getActionForNodes(nodes)) {\n\t\tcase MoveCopyAction.MOVE:\n\t\t\treturn t('files', 'Move')\n\t\tcase MoveCopyAction.COPY:\n\t\t\treturn t('files', 'Copy')\n\t\tcase MoveCopyAction.MOVE_OR_COPY:\n\t\t\treturn t('files', 'Move or copy')\n\t\t}\n\t},\n\ticonSvgInline: () => FolderMoveSvg,\n\tenabled(nodes: Node[]) {\n\t\t// We only support moving/copying files within the user folder\n\t\tif (!nodes.every(node => node.root?.startsWith('/files/'))) {\n\t\t\treturn false\n\t\t}\n\t\treturn nodes.length > 0 && (canMove(nodes) || canCopy(nodes))\n\t},\n\n\tasync exec(node: Node, view: View, dir: string) {\n\t\tconst action = getActionForNodes([node])\n\t\tlet result\n\t\ttry {\n\t\t\tresult = await openFilePickerForAction(action, dir, [node])\n\t\t} catch (e) {\n\t\t\tlogger.error(e as Error)\n\t\t\treturn false\n\t\t}\n\t\ttry {\n\t\t\tawait handleCopyMoveNodeTo(node, result.destination, result.action)\n\t\t\treturn true\n\t\t} catch (error) {\n\t\t\tif (error instanceof Error && !!error.message) {\n\t\t\t\tshowError(error.message)\n\t\t\t\t// Silent action as we handle the toast\n\t\t\t\treturn null\n\t\t\t}\n\t\t\treturn false\n\t\t}\n\t},\n\n\tasync execBatch(nodes: Node[], view: View, dir: string) {\n\t\tconst action = getActionForNodes(nodes)\n\t\tconst result = await openFilePickerForAction(action, dir, nodes)\n\t\tconst promises = nodes.map(async node => {\n\t\t\ttry {\n\t\t\t\tawait handleCopyMoveNodeTo(node, result.destination, result.action)\n\t\t\t\treturn true\n\t\t\t} catch (error) {\n\t\t\t\tlogger.error(`Failed to ${result.action} node`, { node, error })\n\t\t\t\treturn false\n\t\t\t}\n\t\t})\n\n\t\t// We need to keep the selection on error!\n\t\t// So we do not return null, and for batch action\n\t\t// we let the front handle the error.\n\t\treturn await Promise.all(promises)\n\t},\n\n\torder: 15,\n})\n","/**\n * @copyright Copyright (c) 2023 Louis Chmn <louis@chmn.me>\n *\n * @author Louis Chmn <louis@chmn.me>\n *\n * @license AGPL-3.0-or-later\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as\n * published by the Free Software Foundation, either version 3 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see <http://www.gnu.org/licenses/>.\n *\n */\nimport { Node, registerDavProperty } from '@nextcloud/files'\n\nexport function initLivePhotos(): void {\n\tregisterDavProperty('nc:metadata-files-live-photo', { nc: 'http://nextcloud.org/ns' })\n}\n\n/**\n * @param {Node} node - The node\n */\nexport function isLivePhoto(node: Node): boolean {\n\treturn node.attributes['metadata-files-live-photo'] !== undefined\n}\n"],"names":["queue","getQueue","PQueue","MoveCopyAction","canMove","nodes","min","node","Permission","canDownload","_a","_b","attribute","canCopy","getActionForNodes","handleCopyMoveNodeTo","destination","method","overwrite","FileType","t","Vue","NodeStatus","_c","copySuffix","index","client","davGetClient","currentPath","join","davRootPath","destinationPath","target","otherNodes","getUniqueName","n","data","davGetDefaultPropfind","emit","davResultToNode","error","AxiosError","logger","openFilePickerForAction","action","dir","fileIDs","filePicker","getFilePickerBuilder","resolve","reject","_selection","path","buttons","basename","dirnames","paths","CopyIconSvg","FolderMoveSvg","FilePickerClosed","FileAction","view","result","e","showError","promises","initLivePhotos","registerDavProperty","isLivePhoto"],"mappings":"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"}